name: Build, UI & Load Tests (Local Docker)

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  terraform-ui-load-tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: maven

      - name: Setup Chrome
        uses: browser-actions/setup-chrome@v1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      # Terraform: construye imagen y lanza contenedor (local, sin cloud)
      - name: Terraform Init
        working-directory: infra/terraform
        run: terraform init -input=false

      - name: Terraform Apply
        working-directory: infra/terraform
        run: terraform apply -auto-approve -input=false

      # 🔸 Lee outputs con defaults seguros (evita null/null)
      - name: Read TF outputs (safe defaults)
        id: tfout
        working-directory: infra/terraform
        run: |
          set -e
          OUT="$(terraform output -json || echo '{}')"

          BASE_URL=$(echo "$OUT" | jq -r 'try .base_url.value // empty')
          BASE_PATH=$(echo "$OUT" | jq -r 'try .base_path.value // empty')

          : "${BASE_URL:=http://localhost:8080}"
          : "${BASE_PATH:=/}"

          # Normaliza: BASE_URL sin slash final; BASE_PATH con slash inicial y final
          BASE_URL="${BASE_URL%/}"
          case "$BASE_PATH" in
            /*) ;; *) BASE_PATH="/$BASE_PATH" ;; esac
          case "$BASE_PATH" in
            */) ;;  *) BASE_PATH="$BASE_PATH/" ;; esac

          echo "BASE_URL=$BASE_URL"   >> $GITHUB_ENV
          echo "BASE_PATH=$BASE_PATH" >> $GITHUB_ENV
          echo "Resolved BASE_URL=$BASE_URL"
          echo "Resolved BASE_PATH=$BASE_PATH"

      - name: Esperar app (detectar container y ruta de health)
        run: |
            set -e
        
            echo "== Docker PS =="
            docker ps --format 'table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'
        
            # Detecta contenedor que publica 8080->*
            CID=$(docker ps -q --filter "publish=8080" | head -n1)
            if [ -z "$CID" ]; then
              echo "❌ No hay contenedor publicando 8080. Revisa Terraform/ports."; exit 1
            fi
            echo "Usando contenedor: $CID"
        
            # Función para curl que acepta 200-204-401 como 'up'
            is_up() {
              local url="$1"
              code=$(curl -s -o /dev/null -w '%{http_code}' "$url" || true)
              case "$code" in
                200|201|202|203|204|401) return 0 ;;
                *) return 1 ;;
              esac
            }
        
            # Candidatos de health por orden:
            CANDIDATES=()
            # Si BASE_PATH viene de terraform, pruébalo primero
            CANDIDATES+=("${BASE_URL}${BASE_PATH}actuator/health")
            # Fallbacks comunes
            CANDIDATES+=("${BASE_URL}/actuator/health")
            CANDIDATES+=("${BASE_URL}/conversor/actuator/health")
            # Por si la home responde 200
            CANDIDATES+=("${BASE_URL}${BASE_PATH}")
        
            echo "Candidatos de health:"
            printf ' - %s\n' "${CANDIDATES[@]}"
        
            UP_URL=""
            for i in {1..180}; do
              # Si el contenedor murió, salimos con logs
              STATUS=$(docker inspect -f '{{.State.Status}}' "$CID")
              if [ "$STATUS" != "running" ]; then
                echo "❌ Contenedor no está running (estado: $STATUS). Últimos logs:"
                docker logs --tail 200 "$CID" || true
                exit 1
              fi
        
              for url in "${CANDIDATES[@]}"; do
                if is_up "$url"; then
                  UP_URL="$url"
                  break
                fi
              done
        
              if [ -n "$UP_URL" ]; then
                echo "✅ App arriba en: $UP_URL"
                # Exporta la URL efectiva de health por si otros pasos la quieren
                echo "HEALTH_URL=$UP_URL" >> $GITHUB_ENV
                exit 0
              fi
        
              # Cada 15s muestra 50 líneas de log para diagnóstico
              if ! (( i % 15 )); then
                echo "⏳ Aún no responde (t=$i). Últimos logs:"
                docker logs --tail 50 "$CID" || true
              fi
        
              sleep 1
            done
        
            echo "❌ No hubo respuesta HTTP válida tras 180s. Últimos 200 logs:"
            docker logs --tail 200 "$CID" || true
            exit 1
        

      - name: Run UI tests (Selenium)
        env:
          BASE_URL: ${{ env.BASE_URL }}${{ env.BASE_PATH }}conversor
        run: mvn -B -Dtest=ConversorUITest test

      # Re-verifica antes de k6 (si cayó durante UI, reintenta)
      - name: Ensure app alive before k6
        run: |
          URL="${BASE_URL}${BASE_PATH}actuator/health"
          if ! curl -fsS "$URL" >/dev/null 2>&1; then
            echo "⚠️ App caída tras UI. Reintentando 60s..."
            for i in {1..60}; do
              curl -fsS "$URL" >/dev/null 2>&1 && { echo "✅ Volvió"; exit 0; }
              sleep 1
            done
            echo "❌ App no respondió tras reintento"; docker ps -a; exit 1
          fi

      # k6 script (respeta BASE_PATH)
      - name: Create k6 script
        run: |
          mkdir -p tests/perf
          cat > tests/perf/smoke.js <<'K6'
          import http from 'k6/http';
          import { check, sleep } from 'k6';
          const BASE = __ENV.BASE_URL || 'http://localhost:8080';
          const PATH = (__ENV.BASE_PATH || '/');
          export const options = {
            scenarios: {
              health:    { executor: 'constant-vus', vus: __ENV.VUS?parseInt(__ENV.VUS):10, duration: __ENV.DUR||'1m',  exec: 'health' },
              conversor: { executor: 'constant-vus', vus: __ENV.VUS2?parseInt(__ENV.VUS2):10, duration: __ENV.DUR2||'1m', exec: 'conversor', startTime: '5s' }
            },
            thresholds: {
              http_req_failed:   ['rate<0.01'],
              http_req_duration: ['p(95)<800'],
            },
          };
          export function health()   { const r=http.get(`${BASE}${PATH}actuator/health`); check(r,{ '200':x=>x.status===200 }); sleep(1); }
          export function conversor(){ const r=http.get(`${BASE}${PATH}conversor`);       check(r,{ '200':x=>x.status===200 }); sleep(1); }
          K6

      # 🔹 Instalar k6 nativo (APT) y ejecutar desde el host (no Docker)
      - name: Install k6 (APT)
        run: |
          sudo apt-get update
          sudo apt-get install -y ca-certificates gnupg
          sudo mkdir -p /etc/apt/keyrings
          curl -fsSL https://dl.k6.io/key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/k6-archive-keyring.gpg
          echo "deb [signed-by=/etc/apt/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install -y k6
          k6 version

      # Smoke (PR)
      - name: Run k6 (smoke on PR)
        if: ${{ github.event_name == 'pull_request' }}
        run: k6 run --summary-export k6-summary.json tests/perf/smoke.js
        env:
          BASE_URL: ${{ env.BASE_URL }}
          BASE_PATH: ${{ env.BASE_PATH }}
          VUS: "5"
          DUR: "45s"
          VUS2: "5"
          DUR2: "45s"

      # Carga (main)
      - name: Run k6 (load on main)
        if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
        run: k6 run --summary-export k6-summary.json tests/perf/smoke.js
        env:
          BASE_URL: ${{ env.BASE_URL }}
          BASE_PATH: ${{ env.BASE_PATH }}
          VUS: "25"
          DUR: "3m"
          VUS2: "25"
          DUR2: "3m"

      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: surefire-reports-terraform
          path: target/surefire-reports

      - name: Upload k6 summary
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: k6-summary
          path: k6-summary.json

      # Logs útiles si algo sale mal
      - name: Docker state (on failure)
        if: failure()
        run: |
          docker ps -a || true
          docker logs $(docker ps -aq | head -n1) --tail 200 || true

      - name: Terraform Destroy (always)
        if: always()
        working-directory: infra/terraform
        run: terraform destroy -auto-approve -input=false
